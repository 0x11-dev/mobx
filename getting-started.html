<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="mobservable : unobtrusive library to create reactive data structures and self-updating view functions">

  <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
  <link rel="shortcut icon" type="image/png" href="images/favicon.png"/>

  <title>mobservable</title>
  <style>
      pre.prettyprint {
          width: 600px;
          border-color: #fff !important;
      }
      #preview {
          width: 400px;
      }
      .inner {
          max-width: 1024px;
      }
      #main_layout td, #main_layout {
          border-style: none;
      }
  </style>
</head>

<body>

  <!-- HEADER -->
  <div id="header_wrap" class="outer">
    <header class="inner">
      <a id="forkme_banner" href="https://github.com/mweststrate/mobservable">View on GitHub</a>

      <img src="images/mobservable.png" id="logo" />
      <h1 id="project_title">mobservable</h1>
      <h2 id="project_tagline">Unobtrusive reactive library that keeps views automatically in sync with data.</h2>
    </header>
  </div>

  <!-- MAIN CONTENT -->
  <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">
        <table id="main_layout">
            <tr>
                <td>
                    <h1 id="getting-started">Getting started</h1>
                    <p>Mobservable is a library to create reactive state and views.
                    The advantage of reactive state and views is that it achieves <a href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of control</a> in your code.
                    This has major benefits in terms of performance and maintainability of your code; views that are based on your state will be updated automatically.
                    This means that whenever your state changes all views are updated automatically without you needing to do this programmatically:</p>
                    <ul>
                    <li>No code that refreshes views like: <code>redrawTodoList</code> or <code>recalculateOrderTotal</code>.</li>
                    <li>No subscriptions, lenses or cursors to subscribe your views to your data.</li>
                    <li>No <code>setState</code> to refresh your ReactJS components.</li>
                    <li>No unnecessary updates because views <em>might</em> have become stale.</li>
                    </ul>
                    <h1 id="going-from-imperative-to-reactive-code">Going from imperative to reactive code</h1>
                    <p>Instead reactive views automatically are notified by reactive data structures upon each change.
                    Let&#39;s try this in a small example. Suppose you have the following simple data model

<pre class="prettyprint" id="code1">
function TodoStore() {
    this.todos = [];
}

TodoStore.prototype.addTodo = function(task) {
    this.todos.push({
        task: task,
        completed: false
    });
}

TodoStore.prototype.completedTodosCount = function() {
    return this.todos.filter(function(todo) {
        return todo.completed === true;
    }).length;
}

TodoStore.prototype.report = function() {
    var firstTodo = this.todos.length ? this.todos[0].task : "<none>";
    console.log("First todo: '" + firstTodo + "'. Progress: " + this.completedTodosCount() + "/" + this.todos.length);
}

var todoStore = new TodoStore();
</pre>

<p>We have just created a <code>todoStore</code> with a <code>todos</code> collection that can contain <code>Todo</code> objects.
We now can start filling this todoStore with objects. But after each change we have to carefully invoke <code>todoStore.report</code>,
because with each change the report might have changed! For example:</p>

<pre class="prettyprint" id="code2">
todoStore.addTodo("write getting started");
todoStore.report(); // Prints: First todo: 'write getting started'. Progress: 0/1

todoStore.addTodo("present at meekup");
todoStore.report(); // Prints: First todo: 'write getting started'. Progress: 0/2

todoStore.todos[0].completed = true;
todoStore.report(); // Prints: First todo: 'write getting started'. Progress: 1/2

todoStore.todos[1].task = "present at meetup";
todoStore.report(); // Superfluous message: First todo: 'write getting started'. Progress: 1/2

todoStore.todos[0].task = "finish getting started";
todoStore.report(); // Prints: First todo: 'finish getting started'. Progress: 1/2
</pre>
<button onClick="runCode(['#code1', '#code2'])" class="btn-run">Run</button>


<p>But what if we didn&#39;t have to call report explicitly?
What if the data used by the <code>report</code> would make sure our report is updated?
Then we would have achieved inversion of control. That is exactly what mobservable can do for you!</p>
<p>This is what the <code>TodoStore</code> constructor function looks like when using mobservable:</p>


<pre class="prettyprint" id="code3">
var mobservable = require('mobservable');

function TodoStore() {
    this.todos = mobservable.makeReactive([]);
    mobservable.sideEffect(function() {
        this.report();
    }, this);
}

/** addTodo, completedTodosCount and report remain as is */
</pre>

<p>We just changed two things. First, we converted <code>todos</code> from a plain array into an reactive array.
Secondly, we created a function that is invoked automatically whenever any data used by it has changed.
Seems to be too simple to be true right? Let&#39;s try it:</p>

<pre class="prettyprint" id="code4">
todoStore.addTodo("write getting started");         // Prints: First todo: 'write getting started'. Progress: 0/1
todoStore.addTodo("present at meekup");             // Prints: First todo: 'write getting started'. Progress: 0/2
todoStore.todos[0].completed = true;                // Prints: First todo: 'write getting started'. Progress: 1/2
todoStore.todos[1].task = "present at meetup";      // (prints nothing)
todoStore.todos[0].task = "finish getting started"; // Prints: First todo: 'finish getting started'. Progress: 1/2
</pre>

<p>Pretty amazing right? <code>report</code> did not only update automatically, it also did this synchronously and without leaking intermediate values.
It also only updated the report when data <em>actually</em> used in the report was changed.</p>
<p>Next: build a cool user interface around this principle!</p>
<h2 id="reactive-reactjs-components">Reactive ReactJS components</h2>
<p>ReactJS components are (despite their name) not reactive out of the box.
They will not re-render automatically so usually you need either either to call <code>setState</code> or maintain some store/data subscriptions to update your components.</p>
<p>Mobservable provides the <code>reactiveComponent</code> function / decorator that will turn the <code>render</code> method of any method into a reactive function.
From there on, you never have to worry about when to update your component! Similar to what happened to the <code>report</code> function.
This process is <a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/">extremely efficient</a>, as Mobservable will determine the minimum amount of components that need an update.</p>
<p>So a basic, self updating user interface using ReactJS can be achieved by writing just the following dump components:</p>

<pre class="" id="react1">
var reactiveComponent = require('mobservable').reactiveComponent;
var React = require('react');

var TodoList = reactiveComponent(React.createClass({
    displayName: 'TodoList',

    render: function() {
        var store = this.props.store;
        return (<div>
            <ul>
                { store.todos.map(function(todo, idx)
                    return (<TodoView store={ store } todo={ todo } key={ idx } />)
                }) }
            </ul>
            { store.report() }
            <button onClick={ this.onNewTodo }>New Todo</button>
        </div>);
    },

    onNewTodo: function() {
        this.props.store.addTodo(prompt('Enter a new todo:', 'Try mobservable at home!'));
    }
}));

var TodoView = reactiveComponent(React.createClass({
    displayName: 'TodoView',

    render: function() {
        var todo = this.props.todo;
        return (<li>
            <input type='checkbox' checked={ todo.completed } onChange={ this.onToggleCompleted } />
            {todo.title}
        </li>);
    },

    onToggleCompleted: function() {
        this.props.todo.completed = !this.props.todo.completed;
    }
}));

React.render(<TodoList store={todoStore} />, document.getElementById('approot'));
</pre>

<p><a href="listings/getting-started2.html">That&#39;s it</a>! Simple, stateless components that updates themselves in a smart way.
You are now ready to start applying reactiveness to your own applications.</p>
<h2 id="learn-more">Learn more</h2>
<p>Some links</p>
<h2 id="notes">Notes</h2>
<p>For the simplicity of getting started we didn&#39;t make the functions <code>report</code> and <code>completedTodosCount</code> of the <code>TodoStore</code> reactive themselves.
Best practice is to make any function that is defined in terms of the state reactive, so that mobservable can find the minimum amount of calculations needed to update the data. For example, if the name of the first todo was changed, the <code>completedTodosCount</code> function would not be evaluated during updating the <code>report</code>, because the name of the first todo could not have affected the outcome of <code>completedTodosCount</code>.</p>

 </div>

    </td><td>
      <div id="preview" style="width:400px">
          <h3>ReactJS preview</h3>
          <div id="approot">ReactJS app root</div>
          <h3>Console log</h3>
          <button onclick="$('#consoleout').text('')">clear</button>
          <div id="consoleout"></div>
      </div>
  </td></tr></table>
    </section>

</div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
            <p class="copyright">mobservable maintained by <a href="https://github.com/mweststrate">mweststrate</a></p>
            <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
          </footer>
        </div>

        <script src="javascripts/jquery-2.1.4.min.js"></script>
        <script src="javascripts/react-with-addons.js"></script>
        <script src="javascripts/JSXTransformer.js"></script>

        <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-65632006-1");
          pageTracker._trackPageview();
        } catch(err) {}
        </script>

        <script>
            // Save the original source before pretty printer is fired
            $(".prettyprint").each(function(i, elem) {
                $(elem).data('source', $(elem).text());
            });
            function runCode(ids) {
                $(ids.join(",")).each(function(i, elem) {
                    var code = $(elem).data('source');
                    var globalEval = eval; // global scope trick, See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
                    globalEval(transformReact(code));
                });
            };

            $console = $('#consoleout');
            var baseLog = console.log, baseError = console.error;
            console.log = function(arg) {
                baseLog.apply(console, arguments);
                $console.html($console.html() + escapeHtml(arg).replace('\n','<br/>\n') + "<br/>");
            };
            console.error = function(arg) {
                baseError.apply(console, arguments);
                $console.html($console.html() + "<span style='color:red'>" + escapeHtml(arg).replace(/\n/,'<br/>') + "</span><br/>\n");
            };


            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
            };

            function escapeHtml(string) {
                return String(string).replace(/[&<>"'\/]/g, function (s) {
                    return entityMap[s];
                });
            }

            $(document).ready(function() {
                var offset = $("#preview").offset();
                $("#preview").css({
                    position:"fixed",
                    left: offset.left,
                    top: offset.top
                })
            });
        </script>
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
      </body>
      </html>
