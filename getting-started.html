<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="mobservable : unobtrusive library to create reactive data structures and self-updating view functions">

  <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
  <link rel="shortcut icon" type="image/png" href="images/favicon.png"/>

  <title>mobservable</title>
  <style>
      textarea {
          width: 600px;
          border-style: none;
          white-space: pre;
          overflow: auto;
          padding: 20px;
          box-shadow: #ccc 2px 2px 2px;
          font-family: courier new;
          color: #333;
          font-size: 14px;
          text-shadow: #fff 1px 1px;
          margin-top: 10px;
      }
      #preview {
          position: fixed;
          left: 60%;
          right: 0px;
          top: 0px;
          height: 100%;
          border-left: 4px solid #ff9955;
          padding: 40px 20% 40px 20px;
          background: #f2f2f2;
      }
      .outer {
          width: 60%;
          overflow: hidden;
      }
      .inner {
          margin-right:20px;
      }
      #main_layout td, #main_layout {
          border-style: none;
      }
      code {
            padding: 0;
            margin: 0;
            box-shadow: none;
            color: #007edf;
            font-family: courier new;
            background: none;
            font-weight: bold;
      }
      p, li {
        font-size: 19px;
        line-height: 1.3;
        margin-bottom: 0;
        font-family: "freight-text-pro",Georgia,Cambria,"Times New Roman",Times,serif;
        letter-spacing: .01rem;
        font-weight: 400;
        font-style: normal;
      }
      #clear-btn {
          font-size: 8pt;
          border: 2px solid #ccc;
          color: #333;
          padding: 4px 10px;
          float:right;
          cursor: pointer;
          margin-top: 18px;
      }
      .btn-run {
          border: 2px solid #007edf;
          background-color: #007edf;
          color: white;
          float:right;
          margin: -6px -1px 10px;
          padding: 4px 10px;
          font-size: 18px;
          cursor: pointer;
      }
      #reactjs-app {
          margin-left: -20px;
          border-bottom: 4px solid #ff9955;
          padding: 20px;
          width: 100%;
      }
      #consoleout div {
          border-bottom: 1px solid #ccc;
          padding: 4px 0;
          font-family: courier new;
          font-size: 10pt;
      }
      .demo {
          color: #000;
          transition-property: color;
          transition-duration: 0.3s;
          transition-timing-function: ease-out;
      }
      .demo-anim {
          color: #007edf;
      }
  </style>
</head>

<body>

    <div id="preview">
        <h3>ReactJS preview</h3>
        <div id="reactjs-app">ReactJS app</div>
        <button onclick="clearConsole();" id="clear-btn">clear</button>
        <h3>Console log</h3>
        <div id="consoleout"></div>
    </div>

  <!-- HEADER -->
  <div id="header_wrap" class="outer">
    <header class="inner">
      <a id="forkme_banner" href="https://github.com/mweststrate/mobservable">View on GitHub</a>

      <img src="images/mobservable.png" id="logo" />
      <h1 id="project_title">mobservable</h1>
      <h2 id="project_tagline">Five minute introduction to mobservable</h2>
    </header>
  </div>

  <!-- MAIN CONTENT -->
  <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">
                    <h2 id="getting-started">Introduction</h1>
                    <p>Mobservable is a library to create reactive state and views.
                    The advantage of reactive state and views is that it achieves <a target="-_blank" href="https://en.wikipedia.org/wiki/Inversion_of_control"><code>inversion of control</code></a> in your code.
                    This has major benefits in terms of simplicity, maintainability and performance of your code;
                    anything that depends on the state of your application will be updated automatically whenever needed.
                    This removes boilerplate code like refreshing interface parts, maintaining data subscriptions or defining cursors on the state.</p>
                    <h2 id="going-from-imperative-to-reactive-code">Going from imperative to reactive</h2>
                    <p>Sounds promising right? Let's start with a simple example to see how reactiveness might benefit us.
                        All code blocks below are <code>editable</code> and can be run using the <code>run</code> button, in which case their result will be shown on the right.
                        For originalities sake let's start with a simple todo model:
                    </p>

<textarea spellcheck="false" class="prettyprint" id="code1" rows="25">
function TodoStore() {
    this.todos = [];
}

TodoStore.prototype.addTodo = function(task) {
    this.todos.push({
        task: task,
        completed: false
    });
}

TodoStore.prototype.completedTodosCount = function() {
    return this.todos.filter(function(todo) {
        return todo.completed === true;
    }).length;
}

TodoStore.prototype.report = function() {
    if (this.todos.length === 0)
        return "<none>";
    return "First todo: '" + this.todos[0].task
        + "'. Progress: "
        + this.completedTodosCount() + "/" + this.todos.length;
}

var todoStore = new TodoStore();
</textarea>

<p>We have just created a <code>todoStore</code> with a <code>todos</code> collection that can contain todo objects.
Time to fill the <code>todoStore</code> with some objects.
And to see the effect of our changes we carefully invoke <code>todoStore.report</code> after each change:
</p>

<textarea spellcheck="false" class="prettyprint" id="code2" rows="15">
todoStore.addTodo("write getting started");
console.log(todoStore.report());

todoStore.addTodo("present at meekup");
console.log(todoStore.report());

todoStore.todos[0].completed = true;
console.log(todoStore.report());

todoStore.todos[1].task = "present at meetup";
console.log(todoStore.report());

todoStore.todos[0].task = "finish getting started";
console.log(todoStore.report());
</textarea>
<button onClick="runCode(['#code1', '#code2'])" class="btn-run">Run</button>


<p>But what if we didn&#39;t have to call <code>report</code> explicitly?
What if the data used by the report would make sure our report is printed automatically?
Then we would have achieved inversion of control!
That is exactly what mobservable can do for you. Execute code that solely depends on state automatically.</p>
<p>To achieve that, our <code>TodoStore</code> has to be reactive. Let's alter the constructor function just enough to achieve that:</p>


<textarea spellcheck="false" class="prettyprint" id="code3" rows="8">
function TodoStore() {
    this.todos = mobservable.makeReactive([]);
    mobservable.sideEffect(function() {
        console.log(this.report());
    }, this);
}

/** addTodo, completedTodosCount and report remain untouched */


TodoStore.prototype.addTodo = function(task) {
    this.todos.push({
        task: task,
        completed: false
    });
}

TodoStore.prototype.completedTodosCount = function() {
    return this.todos.filter(function(todo) {
        return todo.completed === true;
    }).length;
}

TodoStore.prototype.report = function() {
    if (this.todos.length === 0)
        return "<none>";
    return "First todo: '" + this.todos[0].task
        + "'. Progress: "
        + this.completedTodosCount() + "/" + this.todos.length;
}

var todoStore = new TodoStore();
</textarea>

<p>We just changed two things. First, we converted <code>todos</code> from a plain array into an reactive array.
Secondly, we created a function that prints our report and is invoked automatically whenever any data used by it has changed.
Seems to be too simple to be true right? Let's try altering the data again, but without explicitly invoking the <code>report</code> function:</p>

<textarea spellcheck="false" class="prettyprint" id="code4" rows="6">
todoStore.addTodo("write getting started");
todoStore.addTodo("present at meekup");
todoStore.todos[0].completed = true;
todoStore.todos[1].task = "present at meetup";
todoStore.todos[0].task = "finish getting started";
</textarea>
<button onClick="runCode(['#code3', '#code4'])" class="btn-run">Run</button>

<p>Pretty amazing right? <code>report</code> did not only update automatically, it also did this synchronously and without leaking intermediate values.
It also only updated the report when data <em>actually</em> used in the report was changed.
If you investigate the log carefully, you will see that the fourth line didn't result in a new report being logged.
Next question: can we build complex user interfaces around this principle?</p>
<h2 id="reactive-reactjs-components">Reactive ReactJS components</h2>
<p>ReactJS components are (despite their name) not reactive out of the box.
They will not re-render automatically so usually you need either either to call <code>setState</code> or maintain some store/data subscriptions to update your components.</p>
<p>Mobservable provides the <code>reactiveComponent</code> function / decorator that will turn the <code>render</code> method of any component into a reactive function.
From there on, you never have to worry about when to update your component! Similar to what happened to the <code>report</code> function.
This process is <a target="_blank" href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/">extremely efficient</a>, as Mobservable will determine the minimum amount of components that need an update.</p>
<p>So a basic, self updating user interface using ReactJS can be achieved by writing just the following dumb components:</p>

<textarea spellcheck="false" class="" id="react1" rows="44">
var TodoList = mobservable.reactiveComponent(React.createClass({
    displayName: 'TodoList',

    render: function() {
        var store = this.props.store;
        return (<div className='demo'>
            { store.report() }
            <ul>
                { store.todos.map(function(todo, idx) {
                    return (<TodoView
                        store={ store }
                        todo={ todo }
                        key={ idx }
                    />)
                }) }
            </ul>
            <button onClick={ this.onNewTodo }>New Todo</button>
        </div>);
    },

    onNewTodo: function() {
        this.props.store.addTodo(prompt('Enter a new todo:'));
    }
}));

var TodoView = mobservable.reactiveComponent(React.createClass({
    displayName: 'TodoView',

    render: function() {
        var todo = this.props.todo;
        return (<li className='demo'>
            <input type='checkbox' checked={ todo.completed }
                onChange={ this.onToggleCompleted } />
            {todo.task}
        </li>);
    },

    onToggleCompleted: function() {
        this.props.todo.completed = !this.props.todo.completed;
    }
}));

React.render(<TodoList store={todoStore} />,
    document.getElementById('reactjs-app'));
</textarea>
<button onClick="runCode(['#code3', '#code4', '#react1'])" class="btn-run">Run</button>

<p>That&#39;s it! Simple, stateless components that updates themselves in a smart way.
You are now ready to start applying reactiveness to your own applications. Or just play some more by editing the components above or the following state changing statements:</p>
<textarea spellcheck="false" class="" id="play1" rows="8">
todoStore.todos[todoStore.todos.length] = { task: "Find a fine cheese", completed: true };
todoStore.todos[0].completed = !todoStore.todos[0].completed;
// etc etc.. type your own statements here:
</textarea>
<button onClick="runCode(['#play1'])" class="btn-run">Run</button>

<h2 id="learn-more">Learn more</h2>
<p>Some links</p>
<h2 id="notes">Notes</h2>
<p>For the simplicity of getting started we didn&#39;t make the functions <code>report</code> and <code>completedTodosCount</code> of the <code>TodoStore</code> reactive themselves.
Best practice is to make any function that is defined in terms of the state reactive, so that mobservable can find the minimum amount of calculations needed to update the data. For example, if the name of the first todo was changed, the <code>completedTodosCount</code> function would not be evaluated during updating the <code>report</code>, because the name of the first todo could not have affected the outcome of <code>completedTodosCount</code>.</p>

 </div>
    </section>

</div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
            <p class="copyright">mobservable maintained by <a href="https://github.com/mweststrate">mweststrate</a></p>
            <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
          </footer>
        </div>

        <script src="javascripts/jquery-2.1.4.min.js"></script>
        <script src="javascripts/react-with-addons.js"></script>
        <script src="javascripts/JSXTransformer.js"></script>
        <script src="javascripts/mobservable.js"></script>

        <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-65632006-1");
          pageTracker._trackPageview();
        } catch(err) {}
        </script>

        <script>
            // Save the original source before pretty printer is fired
            function runCode(ids) {
                $(ids.join(",")).each(function(i, elem) {
                    clearConsole();
                    var code = $(elem).val();
                    var globalEval = eval; // global scope trick, See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
                    code = JSXTransformer.transform(code).code;
                    try {
                        globalEval(code);
                    } catch (e) {
                        console.error(e);
                    }
                });
            };

            $console = $('#consoleout');
            var baseLog = console.log, baseError = console.error;
            console.log = function(arg) {
                baseLog.apply(console, arguments);
                $console.html($console.html() + "<div>" + escapeHtml(arg).replace('\n','<br/>\n') + "</div>");
            };
            console.error = function(arg) {
                baseError.apply(console, arguments);
                $console.html($console.html() + "<div style='color:red'>" + escapeHtml(arg).replace(/\n/,'<br/>') + "</div>\n");
            };

            function clearConsole() {
                $('#consoleout').text('')
            }

            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
            };

            function escapeHtml(string) {
                return String(string).replace(/[&<>"'\/]/g, function (s) {
                    return entityMap[s];
                });
            }

            setInterval(function() {
                $(".demo").addClass("demo-anim");
            }, 500);

            document.body.addEventListener("transitionend", function(e) {
                $(e.target).removeClass('demo').removeClass('demo');
            });

            //runCode(['#code3', '#code4', '#react1']);
            //clearConsole();

        </script>
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
      </body>
      </html>
