<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>createTransformer · MobX</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# createTransformer"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="createTransformer · MobX"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mobx.js.org//"/><meta property="og:description" content="# createTransformer"/><meta property="og:image" content="https://mobx.js.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mobx.js.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-65632006-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://codefund.app/properties/259/funder.js" async=""></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mobx.png" alt="MobX"/><h2 class="headerTitleWithLogo">MobX</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/intro/concepts" target="_self">Documentation</a></li><li class=""><a href="https://github.com/mobxjs/mobx" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Utility functions</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/README">Introduction</a></li><li class="navListItem"><a class="navItem" href="/intro/concepts">Concepts &amp; Principles</a></li><li class="navListItem"><a class="navItem" href="/intro/overview">The gist of MobX</a></li><li class="navListItem"><a class="navItem" href="/refguide/api">API overview</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Making things observable</h3><ul class=""><li class="navListItem"><a class="navItem" href="/refguide/observable">observable</a></li><li class="navListItem"><a class="navItem" href="/refguide/observable-decorator">@observable</a></li><li class="navListItem"><a class="navItem" href="/refguide/object">objects</a></li><li class="navListItem"><a class="navItem" href="/refguide/array">arrays</a></li><li class="navListItem"><a class="navItem" href="/refguide/map">maps</a></li><li class="navListItem"><a class="navItem" href="/refguide/boxed">boxed values</a></li><li class="navListItem"><a class="navItem" href="/refguide/modifiers">decorators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Reacting to observables</h3><ul class=""><li class="navListItem"><a class="navItem" href="/refguide/computed-decorator">(@)computed</a></li><li class="navListItem"><a class="navItem" href="/refguide/autorun">autorun</a></li><li class="navListItem"><a class="navItem" href="/refguide/when">when</a></li><li class="navListItem"><a class="navItem" href="/refguide/reaction">reaction</a></li><li class="navListItem"><a class="navItem" href="/refguide/observer-component">(@)observer</a></li><li class="navListItem"><a class="navItem" href="/best/react">Understanding what MobX reacts to</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Changing observables</h3><ul class=""><li class="navListItem"><a class="navItem" href="/refguide/action">action</a></li><li class="navListItem"><a class="navItem" href="/best/actions">async actions &amp; flows</a></li><li class="navListItem"><a class="navItem" href="/refguide/object-api">Object api</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Utility functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/refguide/tojson">toJS</a></li><li class="navListItem"><a class="navItem" href="/refguide/extend-observable">extendObservable</a></li><li class="navListItem"><a class="navItem" href="/refguide/extending">createAtom</a></li><li class="navListItem"><a class="navItem" href="/refguide/observe">intercept &amp; observe</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/refguide/create-transformer">mobxUtils.createTransformer</a></li><li class="navListItem"><a class="navItem" href="/refguide/expr">mobxUtils.expr</a></li><li class="navListItem"><a class="navItem" href="/refguide/mobx-utils">MobX-utils</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tips &amp; Tricks</h3><ul class=""><li class="navListItem"><a class="navItem" href="/faq/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/best/pitfalls">Common Pitfalls &amp; Best Practices</a></li><li class="navListItem"><a class="navItem" href="/best/decorators">How to (not) use decorator syntax</a></li><li class="navListItem"><a class="navItem" href="/best/trace">Using trace for debugging</a></li><li class="navListItem"><a class="navItem" href="/best/store">Defining data stores</a></li><li class="navListItem"><a class="navItem" href="/best/react-performance">Optimizing React components</a></li><li class="navListItem"><a class="navItem" href="/refguide/spy">spy</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/mobxjs/mobx/edit/master/docs/refguide/create-transformer.md" target="_blank" rel="noreferrer noopener">Edit</a></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="createtransformer"></a><a href="#createtransformer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>createTransformer</h1>
<div id='codefund' ></div>
<p>Provided by the <code>mobx-utils</code> package.</p>
<p><code>createTransformer&lt;A, B&gt;(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> turns a function (that should transform value <code>A</code> into another value <code>B</code>) into a reactive and memoizing function.
In other words, if the <code>transformation</code> function computes B given a specific A, the same B will be returned for all other future invocations of the transformation with the same A.
However, if A changes, the transformation will be re-applied so that B is updated accordingly.
And last but not least, if nobody is using the transformation of a specific A anymore, its entry will be removed from the memoization table.</p>
<p>With <code>createTransformer</code> it is very easy to transform a complete data graph into another data graph.
Transformation functions can be composed so that you can build a tree using lots of small transformations.
The resulting data graph will never be stale, it will be kept in sync with the source by applying small patches to the result graph.
This makes it very easy to achieve powerful patterns similar to sideways data loading, map-reduce, tracking state history using immutable data structures etc.</p>
<p>The optional <code>onCleanup</code> function can be used to get a notification when a transformation of an object is no longer needed.
This can be used to dispose resources attached to the result object if needed.</p>
<p>Always use transformations inside a reaction like <code>@observer</code> or <code>autorun</code>.
Transformations will, like any other computed value, fall back to lazy evaluation if not observed by something, which sort of defeats their purpose.</p>
<p>This all might still be a bit vague, so here are two examples that explain this whole idea of transforming one data structure into another by using small, reactive functions:</p>
<h2><a class="anchor" aria-hidden="true" id="tracking-mutable-state-using-immutable-shared-data-structures"></a><a href="#tracking-mutable-state-using-immutable-shared-data-structures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tracking mutable state using immutable, shared data structures.</h2>
<p>This example is taken from the <a href="https://github.com/mobxjs/mobx-reactive2015-demo">Reactive2015 conference demo</a>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/*
    The store that holds our domain: boxes and arrows
*/</span>
<span class="hljs-keyword">const</span> store = observable({
    <span class="hljs-attr">boxes</span>: [],
    <span class="hljs-attr">arrows</span>: [],
    <span class="hljs-attr">selection</span>: <span class="hljs-literal">null</span>
});

<span class="hljs-comment">/**
    Serialize store to json upon each change and push it onto the states list
*/</span>
<span class="hljs-keyword">const</span> states = [];

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    states.push(serializeState(store));
});

<span class="hljs-keyword">const</span> serializeState = createTransformer(<span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> ({
    <span class="hljs-attr">boxes</span>: store.boxes.map(serializeBox),
    <span class="hljs-attr">arrows</span>: store.arrows.map(serializeArrow),
    <span class="hljs-attr">selection</span>: store.selection ? store.selection.id : <span class="hljs-literal">null</span>
}));

<span class="hljs-keyword">const</span> serializeBox = createTransformer(<span class="hljs-function"><span class="hljs-params">box</span> =&gt;</span> ({...box}));

<span class="hljs-keyword">const</span> serializeArrow = createTransformer(<span class="hljs-function"><span class="hljs-params">arrow</span> =&gt;</span> ({
    <span class="hljs-attr">id</span>: arrow.id,
    <span class="hljs-attr">to</span>: arrow.to.id,
    <span class="hljs-attr">from</span>: arrow.from.id
}));
</code></pre>
<p>In this example the state is serialized by composing three different transformation functions.
The autorunner triggers the serialization of the <code>store</code> object, which in turn serializes all boxes and arrows.
Let's take closer look at the life of an imaginary example box#3.</p>
<ol>
<li>The first time box#3 is passed by <code>map</code> to <code>serializeBox</code>,
the serializeBox transformation is executed and an entry containing box#3 and its serialized representation is added to the internal memoization table of <code>serializeBox</code>.</li>
<li>Imagine that another box is added to the <code>store.boxes</code> list.
This would cause the <code>serializeState</code> function to re-compute, resulting in a complete remapping of all the boxes.
However, all the invocations of <code>serializeBox</code> will now return their old values from the memoization tables since their transformation functions didn't (need to) run again.</li>
<li>Secondly, if somebody changes a property of box#3 this will cause the application of the <code>serializeBox</code> to box#3 to re-compute, just like any other reactive function in MobX.
Since the transformation will now produce a new Json object based on box#3, all observers of that specific transformation will be forced to run again as well.
That's the <code>serializeState</code> transformation in this case.
<code>serializeState</code> will now produce a new value in turn and map all the boxes again. But except for box#3, all other boxes will be returned from the memoization table.</li>
<li>Finally, if box#3 is removed from <code>store.boxes</code>, <code>serializeState</code> will compute again.
But since it will no longer be using the application of <code>serializeBox</code> to box#3,
that reactive function will go back to non-reactive mode.
This signals the memoization table that the entry can be removed so that it is ready for GC.</li>
</ol>
<p>So effectively we have achieved state tracking using immutable, shared datas structures here.
All boxes and arrows are mapped and reduced into single state tree.
Each change will result in a new entry in the <code>states</code> array, but the different entries will share almost all of their box and arrow representations.</p>
<h2><a class="anchor" aria-hidden="true" id="transforming-a-datagraph-into-another-reactive-data-graph"></a><a href="#transforming-a-datagraph-into-another-reactive-data-graph" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transforming a datagraph into another reactive data graph</h2>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects.
This can be used to transform an observable data graph into a another observable data graph, which can be used to transform... you get the idea.</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change.
Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code,
compared to derived data graph that are updated using your own code. See the <a href="https://github.com/mobxjs/mobx/blob/3ea1f4af20a51a1cb30be3e4a55ec8f964a8c495/test/perf/transform-perf.js#L4">performance tests</a> for some examples.</p>
<p>Unlike the previous example, the <code>transformFolder</code> will only run once as long as a folder remains visible;
the <code>DisplayFolder</code> objects track the associated <code>Folder</code> objects themselves.</p>
<p>In the following example all mutations to the <code>state</code> graph will be processed automatically.
Some examples:</p>
<ol>
<li>Changing the name of a folder will update its own <code>path</code> property and the <code>path</code> property of all its descendants.</li>
<li>Collapsing a folder will remove all descendant <code>DisplayFolders</code> from the tree.</li>
<li>Expanding a folder will restore them again.</li>
<li>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</li>
<li>Etc.</li>
</ol>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mobx'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Folder</span>(<span class="hljs-params">parent, name</span>) </span>{
    <span class="hljs-keyword">this</span>.parent = parent;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">children</span>: m.observable.shallow([]),
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DisplayFolder</span>(<span class="hljs-params">folder, state</span>) </span>{
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.folder = folder;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-keyword">get</span> name() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.name;
        },
        <span class="hljs-keyword">get</span> isVisible() {
            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.state.filter || <span class="hljs-keyword">this</span>.name.indexOf(<span class="hljs-keyword">this</span>.state.filter) !== <span class="hljs-number">-1</span> || <span class="hljs-keyword">this</span>.children.some(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.isVisible);
        },
        <span class="hljs-keyword">get</span> children() {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.collapsed)
                <span class="hljs-keyword">return</span> [];
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.children.map(transformFolder).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
                <span class="hljs-keyword">return</span> child.isVisible;
            })
        },
        <span class="hljs-keyword">get</span> path() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.parent === <span class="hljs-literal">null</span> ? <span class="hljs-keyword">this</span>.name : transformFolder(<span class="hljs-keyword">this</span>.folder.parent).path + <span class="hljs-string">"/"</span> + <span class="hljs-keyword">this</span>.name;
        })
    });
}

<span class="hljs-keyword">var</span> state = m.observable({
    <span class="hljs-attr">root</span>: <span class="hljs-keyword">new</span> Folder(<span class="hljs-literal">null</span>, <span class="hljs-string">"root"</span>),
    <span class="hljs-attr">filter</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">displayRoot</span>: <span class="hljs-literal">null</span>
});

<span class="hljs-keyword">var</span> transformFolder = m.createTransformer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">folder</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DisplayFolder(folder, state);
});


<span class="hljs-comment">// returns list of strings per folder</span>
<span class="hljs-keyword">var</span> stringTransformer = m.createTransformer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">displayFolder</span>) </span>{
    <span class="hljs-keyword">var</span> path = displayFolder.path;
    <span class="hljs-keyword">return</span> path + <span class="hljs-string">"\n"</span> +
        displayFolder.children.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">return</span> child.isVisible;
        }).map(stringTransformer).join(<span class="hljs-string">''</span>);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFolders</span>(<span class="hljs-params">parent, recursion</span>) </span>{
    <span class="hljs-keyword">if</span> (recursion === <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-keyword">var</span> folder = <span class="hljs-keyword">new</span> Folder(parent, i + <span class="hljs-string">''</span>);
        parent.children.push(folder);
        createFolders(folder, recursion - <span class="hljs-number">1</span>);
    }
}

createFolders(state.root, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3^2</span>

m.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    state.displayRoot = transformFolder(state.root);
    state.text = stringTransformer(state.displayRoot)
    <span class="hljs-built_in">console</span>.log(state.text)
});

state.root.name = <span class="hljs-string">'wow'</span>; <span class="hljs-comment">// change folder name</span>
state.displayRoot.children[<span class="hljs-number">1</span>].collapsed = <span class="hljs-literal">true</span>; <span class="hljs-comment">// collapse folder</span>
state.filter = <span class="hljs-string">"2"</span>; <span class="hljs-comment">// search</span>
state.filter = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unsearch</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/refguide/observe"><span class="arrow-prev">← </span><span>intercept &amp; observe</span></a><a class="docs-next button" href="/refguide/expr"><span class="function-name-prevnext">mobxUtils.expr</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#tracking-mutable-state-using-immutable-shared-data-structures">Tracking mutable state using immutable, shared data structures.</a></li><li><a href="#transforming-a-datagraph-into-another-reactive-data-graph">Transforming a datagraph into another reactive data graph</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mobx.png" alt="MobX" width="66" height="58"/></a><div><h5>Docs</h5><a href="/en/README">Why MobX</a><a href="/en/intro/concepts">Concepts</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/mobx" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://gitter.im/mobxjs/mobx">Project Chat</a></div><div><h5>More</h5><a class="github-button" href="https://github.com/mobxjs/mobx" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>