Initial build process

Original:
---------
Import size report for mobx:
┌──────────────────────┬───────────┬────────────┬───────────┐
│       (index)        │ just this │ cumulative │ increment │
├──────────────────────┼───────────┼────────────┼───────────┤
│ import * from 'mobx' │   16602   │     0      │     0     │
│      observable      │   13842   │   13842    │     0     │
│       computed       │   13915   │   13930    │    88     │
│       autorun        │   13845   │   13946    │    16     │
└──────────────────────┴───────────┴────────────┴───────────┘
(this report was generated by npmjs.com/package/import-size)

After removing decorators;
-----------------
Import size report for mobx:
┌──────────────────────┬───────────┬────────────┬───────────┐
│       (index)        │ just this │ cumulative │ increment │
├──────────────────────┼───────────┼────────────┼───────────┤
│ import * from 'mobx' │   17581   │     0      │     0     │
│      observable      │   14563   │   14563    │     0     │
│       computed       │   14563   │   14577    │    14     │
│       autorun        │   14563   │   14590    │    13     │
│        action        │   14563   │   14602    │    12     │
│   enableDecorators   │   14566   │   14617    │    15     │
└──────────────────────┴───────────┴────────────┴───────────┘
(this report was generated by npmjs.com/package/import-size)


[ ] TSDX build process
[ ] enableDecorators
[ ] update docs regarding tsconfig
[ ] update docs for non-default decoratres
[ ] minimal dev errors
[ ] invariant system from immer
[ ] update tsconfig, no decorators, yes define
[ ] in v5 next minor: warn if decorators are used
[ ] gotcha: in subclasses don't redefine fields, (test: mbox should refuse to re-decorate a field)
[ ] decorate(this, { "*": true })
[ ] decorate(this)
[ ] use normal imports in tests
[ ] think about alternative syntaxes
[ ] code mod, run on v4 tests?
[ ] check errors *if* decorators are used
[ ] alternative syntax: `x = decorate.observable(y)`?
[ ] backport tests and code to v4(6)
[ ] macro transform
[ ] codemod TS
[ ] keep decorate calls?
[ ] codemod babel
[ ] codemod leave decorators
[ ] reflect metadata
[ ] instruct using TS / Babel decorators
[ ] combine with ES5?
[ ] get rid of all that pending decorators shizzle
[ ] Todo: check how important array of decorators is, see original issue -> This will be breaking issue, as we are going to treat action etc different?
[ ] tests for redefining properties
[ ] extract utils for getOwnPropertyDescriptor and defineProperty
[ ] introduce observable.box
[ ] add test for initializers that refer to other props
[ ] create warning when box is accessed without constructor call (e.g. when reading a primtive from observable() rather than observable.box())
[ ] migrate decorate calls as well
[ ] figure out what to do with decorate(object, stuff). Use extendObservable / observable instead?
[ ] optimization tip: hoist the mapping constant
[ ] document: uncoditional map
[ ] handle conversion of decorate objects
[ ] autoConversion, reflect meta data, very strict typing of makeObservabel
[ ] observable / extendObservable use decorators args
[ ] observable; support `false` as argument
[ ] breaking: function are now actions by default!
[ ] verify: action called from computed throws?
[ ] document `true` and `false` as annotations
[ ] breaking: can no longer re-decorate fields already decorated by a superclass
[ ] make sure legacy array implementation is opt in
[ ] compare mobx.configure options between v4 and v5

General class solutions
- call extendObservable in constructor
  - works always
  - untyped
- call decorate in constructor
  - works always
  - typesafe
  - little verbose
- X class Box extends Observable({ x: 3 }) { }
  - short
  - this in props is often not typed
  - cannot refer forward to funcions defined in the class
- X class Box extends Observable(class { x: 3 })
  - no way to opt out of non-observable members, distinguish utility functions from actions
- class Box extends Observable(class, decorators) {}
  - works with statics
  - can use const Box = Observable(class, decorators) to make it shorter
- Utility members: [obervable()] height = 20
  - typescript doesn't allow dynamic expressions or duplicate decorators that way
  - would work fine in javascript :'(
- [decorators.observable] = params field = value
  - works!
  - breaks if deconstructed
  - breaks without defineFieldAsProperties
  - has implicit any type...
  - looks weird with semicolons enabled
  - http://www.typescriptlang.org/play/?useDefineForClassFields=true&target=2#code/DYUwLgBAlhC8EAYDcAoAxgewHYGdIBMRMAnAQzA2JzggG8UJGIBzcCDAIxxGIDdSOoABQBKAFwQARJ258BoSXQZMVAelUQAAmBwBaKMyyUQylY2LgArsSxSZPfoJAB9RQGpobt6YgBfFP7owKQ41ABCGAAeSioA2oQk5JQ4AHT2ck4Auqgq0fAAzDlM8USUSVRpXA7yINk+AJ40hQFAA
- [util properties] like x$ = computed.observable
  - verify at runtime
  - show up public api
  - can use never type

Things fixed:
- initialization in babel
- babel setup
- forward compatible with new field initialzers (in babel / ts flag)
- CRA setup out of the box
- size reduction
- maintainability
- migration:
  - codemod
  - babel macro / transform

or, new package: mobx.next? no spy and intercept either?

To Document:
-  height = observable<20>(20)

Breaking changes:
- no generic decorators or lists anymore for extendObservable?
- removed `decorate()`

Running codemod

yarn jscodeshift -t codemod/undecorate.ts test/v5/base/typescript-tests.ts --ignoreImports=true

Blog post:

Less dev ergonomics. But
- unblocks future lang compatiblity (define semantics)
- easier to adopt (this benefits everyone!)
- compatiblity with CRA, eslint, etc etc out of the box
- reduce library size
- not two ways to learn everything
- ease to re-decorate once decorators are standardized, still working on that!
